{
    "title": "SegFuzz： 쓰레드 인터리빙 분할 기법을 활용한 커널의 동시성 버그 퍼징",
    "date": "2024-04-04T00:00:00Z",
    "link": "https://cs.kaist.ac.kr/board/view?bbs_id=research&bbs_sn=11053&page=1&skey=subject&svalue=&menu=265",
    "content": "커널 동시성 버그 (kernel concurrency bug)를 탐지하는 일은 매우 어려운 일이다. 이는 비동시성 버그와 다르게, 커널 동시성 버그를 식별하려면 여러 스레드 간의 인터리빙에 대한 분석이 필요하기 때문이다. 그러나 스레드 인터리빙의 검색 공간은 방대하기 때문에, 가능한 모든 스레드 인터리빙을 조사하는 것은 사실상 불가능하다. 이런 방대한 검색 공간을 탐색하기 위해 대부분의 이전 연구들은 스레드 인터리빙에 대한 무작위 또는 휴리스틱 (heuristic)에 기반한 검색을 수행한다. 이 때문에, 이전 연구들은 중복된 실행으로 인해 컴퓨팅 자원을 낭비하거나, 테스팅 과정에서 동시성 버그를 찾지 못 하는 경우가 발생한다.\n이러한 한계를 극복하기 위해, 본 연구는 커널 동시성 버그에 대한 퍼징 프레임워크인 SegFuzz를 제안한다. 스레드 인터리빙의 검색 공간을 탐색할 때, SegFuzz는 전체 스레드 인터리빙을 소수의 명령어의 인터리빙인 명령어 조각 (interleaving segment)으로 분해하여, 스레드 인터리빙의 탐색 정도를 나타낸다. 스레드 인터리빙을 검색할 때에는, 탐색된 명령어 조각의 인터리빙을 변경 (mutate)하여 아직 탐색되지 않은 새로운 스레드 인터리빙을 구성한다. 이러한 탐색 기법을 최초로 고안하여 커널 동시성 버그 탐지에 적용하여 그 효율성을 입증하였다.본 연구팀은 SegFuzz를 활용하여 Linux 커널에서 새로운 30개 (그 중 21개가 confirmed 혹은 고처짐)의 동시성 버그를 발견할 수 있음을 보이고, SegFuzz가 Google의 Syzkaller 시스템보다 약 4000배 빠르게 알려진 버그를 식별할 수 있음을 실험을 통해 입증하였다.\n1. 연구배경\nFuzz testing (fuzzing)은 시스템 소프트웨어의 취약점을 찾기 위한 소프트웨어 테스팅 기법으로, 리눅스 커널을 포함한 수많은 시스템 소프트웨어의 취약점을 성공적으로 탐지함으로써 우수성을 입증하고 있다. 전통적인 fuzzing은 단일 스레드에서 실행 경로의 탐색 공간을 탐색함으로써 취약점을 탐지한다. 이에 따라, 많은 연구자들은 어떻게 더 효과적으로 실행 경로를 탐색하는 fuzzing 기법을 만들 수 있을지 고민해왔다.\n하지만 리눅스 커널과 같은 복잡한 시스템 소프트웨어는 복수의 스레드들이 동시에 실행되는 환경을 제공하며, 이러한 환경에서는 동시성 버그라는 전통적인 fuzzing이 효과적으로 탐지하지 못 하는 버그가 존재한다. 동시성 버그는 실행 경로 뿐만 아니라 스레드 인터리빙 (thread interleaving)에 의해 발생하는 버그이다. 따라서, fuzzing이 동시성 버그를 효과적으로 탐지하기 위해서는 실행 경로 뿐만 아니라 스레드 인터리빙의 탐색 공간을 효과적으로 탐색하기 위한 기법이 필요하다.\n하지만, 스레드 인터리빙의 탐색 공간은 어마어마하게 넓다. 명령어의 수가 늘어나면, 가능한 스레드 인터리빙의 경우의 수는 기하급수적으로 늘어남은 잘 알려져 있다. 이 때문에, 동시성 버그를 효과적으로 탐지하기 위해서는 스레드 인터리빙의 탐색 공간을 똑똑하게 탐색하기 위한 기법이 필요하다. 본 연구는 동시성 버그를 효과적으로 탐지하기 위하여, 스레드 인터리빙의 탐색 공간을 효과적으로 탐색하기 위한 기법을 연구한다.\n2. 연구내용\n그림 Segmentation 예제. (a) 두 스레드가 실행한 명령어들. (b) 실행된 명령어들로부터 추출된 segment들\n스레드 인터리빙의 탐색 공간을 효과적으로 탐색하기 위해서는 스레드 인터리빙이 어떻게 동시성 버그를 발생시키는지 이해해야 한다. 한 연구에 따르면, 대부분 (약 93％)의 동시성 버그는 최대 4개의 명령어 (instruction)들의 실행 순서에 따라 발생한다고 한다. 즉, 복수의 스레드들이 무수히 많은 수의 명령어를 실행하더라도, 최대 4개의 명령어들이 특정 실행 순서에 따라 실행된다면 동시성버그가 발생하고, 한 번 테스트한 실행 순서는 다시 테스트할 필요가 없다.\nSegFuzz는 이러한 발견을 바탕으로 디자인되었다. SegFuzz는 스레드들이 실행한 많은수의 명령어들을 최대 4개의 명령어를 포함하는 명령어 조각 (interleaving segment)을 구성한다 (그림 1. 참조). 앞서 언급한 발견에 따라 이 명령어 조각들이 나타내는 실행 순서는 다시 테스트할 필요가 없다 (중복 제거). 따라서, SegFuzz는 각각의 명령어 조각내의 명령어들의 실행 순서를 변경 (mutate)하여, 테스트할 새로운 실행 순서를 유추한다. 이러한 방식으로, SegFuzz는 스레드 인터리빙 탐색 문제의 복잡도를 크게 낮춰, 효율적으로 동시성 버그를 탐지한다.\n3. 기대효과\n디버깅으로 발생하는 비용은 ＄312 billion dollar로 추산된다.\nhttps://undo.io/media/uploads/files/Undo_ReversibleDebugging_Whitepaper.pdf\n그 중 동시성 프로그램 버그는 가장 찾기 어려운 버그로 10년이상 발견되지 않는 버그들도 존재한다. 동시성 버그를 활용하여 시스템 운영자 권한을 획득하는 공격사례도 빈번하게 보고되고 있다 .\nhttps://dl.acm.org/doi/pdf/10.1145/3552326.3567486\n본 연구는 이러한 동시성 버그의 존재를 획기적으로 빠르게 찾아줄 수 있는 퍼징 기법을 제공하여 개발자들의 동시성 버그 디버깅 시간을 단축시켜 개발 비용 절감과 시스템의 안정성을 이룰 수 있게 해준다. 본 연구에서 개발한 퍼징 시스템으로 리눅스 커널에서 시스템 크래쉬나 관리자 권한을 획득할 수 있는 실제 버그를 30여개 발견하였고 이 중 21개의 버그는 커널 개발자들에 의해서 confirm되거나 패치가 이루어졌다. 이는 SegFuzz의 탐색 기법을 통해 최신의 기존의 동시성 버그 탐지 연구들보다 짧은 기간에 커널의 다양한 코드를 빠르게 탐색 할 수 있었기 때문인다. 대표적으로 Google의 Syzkaller 보다 최대 약 4000배 정도의 빠른 탐색 성능을 실험을 통해 보여주었다.\n4. 연구실적\n〇 연구실적\nSEGFUZZ: Segmentizing Thread Interleaving to Discover Kernel Concurrency Bugs through Fuzzing, IEEE S&P (acceptance rate = 12％)\n〇 Linux kernel bug 발견 및 report\nLinux kernel 버전 5.19 – 6.0 (논문 연구당시의 최신 커널)이서 30개의 버그가 새롭게 발견되었고, 21개의 버그가 개발자에 의해서 확인되었고 고쳐졌다.",
    "tag": "csweb.ai",
    "id": 14
}